# algorithm 공부

이전
- 이것이 코딩테스트다
- 예제 풀이

2021.09.13 
- 정규식 공부 후 문자열 관련 문제 3문제 sol
- [comparator과 sort] 문자열 내 마음대로 정렬하기.java
- [정규식과 replaceAll] 신규아이디 추천.java
- [replaceAll] 문자숫자열과 영단어.java


2021.12.22
- leetcode 문제 sol
- JewelsAndStones.java  
-두개의 String이 주어졌을 때, 하나의 String안에 distinctive한 char 값이 다른 String 안에 포함되었는지를 판별하는 문제  
-String을 toCharArray()로 두개의 String을 Character배열로 전환  
-containg함수를 쓰기 위해 Character형 HashSet 사용
- UniqueEmail.java  
-@값을 기준으로 로컬네임과 도메인네임으로 String 분리 후 각각의 규칙에 맞게 String 가공  
-replaceAll과 Split 함수 사용
- plusOne.java  
-문자열 함수를 사용했다기 보다 indexing하는게 더 어려웠던 문제 > flag 같은 배열을 하나 더 추가해서 solve


2022.03.05
- **** 실수 list *****
- [bfs] 큐 안에서 인덱스는 항상 remove() 해온거 기준으로 하기. 명심 또 명심.
- [dfs] 최대값을 가져와야 하는 경우 return 부분에서 항상 비교 후에 최대값 return! 


2022.03.06
- notice! bfs/네트워크.java 에서는 입력값이 2차원이지만 양방향그래프이기떄문에 체크를 1차원 배열로 하였다. 한번 더 보면 좋을 듯하다.

2022.03.12
- 네트워크 문제를 dfs로 풀어보았다. 탐색의 시작은 항상 직전 탐색의 마지막 지점에서 이루어져야함을 잊지 말자

2022.03.16
- 단어 변환. 반성한다.
반성할점 1. 문제 해석을 잘못했다. 주어진 단어 목록에서 무조건 순차적으로 탐색을 해야되는 줄 알았다.
반성할점 2. 그래서 그 조합문제처럼 경우의 수에 따라 dfs 탐색을 해버렸다. 
 - 바꿀수 있어서 바꾼 케이스
 - 바꿀수 있는데 안바꾼 케이스
 - 바꿀수 없는 케이스
반성할점 3. 근데 그게 아니라 단어 목록을 차례대로 순회하면서 방문한 단어를 시작으로 매번 단어 목록을 재탐색하는거였다.
          그래서 방문처리가 필요한거였음. 그리고 순회가 끝나면 방문처리를 지워줘야 하는 것도 최소값을 찾는거기 떄문에 방문처리배열을 재사용해야되기 때문

결론. 문제가 막막하다면 아래와 같은 체크 리스트를 생각해보자
1. 탐색에 필요한 기준 데이터가 잘 설정 되었는가
2. 동일 대상에 대해 여러번 탐색이 필요한가 ( 최소값/ 최대값 ) - 네트워크의 경우는 여러번 탐색하지 않아도 됐다.
3. 방문처리를 제때 잘 해주었는가
